//所有的问题都可以转为子问题来解决
//分治与回溯都是一种特殊的递归
//自定向下的编码，

/**
 * 分治思想
 * 对于一个问题，化解为好几个子问题
 *
 */

/**
 * 回溯
 * 递归的一种方式
 * 试错的方式进行解决问题，参试分布的解决一个问题  八皇后
 */
const generate = () => {};


/**
 * 贪心算法
 * 是一种在每一步选择中都采取在当前状态下最好或者最优的选择，从而希望导致结果是全局最好或最有的算法
 * 
 * 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前惊醒选择，有回退功能
 * 
 * 贪心：当下做局部最优判断
 * 回溯：能够回退
 * 动态规划： 最有判断 + 回退  会保存之前的计算结果 以及可以回退
 * 
 * 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，并且不能回退， 动态规划则会保存以前的运算结果，并且根绝以前的结果对当前进行选择，有回退的功能
 */

 //递归模板
var recur = (level, param) => {
  //递归终止条件
  if (level > target) return;

  //处理当前逻辑
  process(level, param);

  //drill down
  recur(level + 1, param)
 }

 /**
  * 动态规划  分治+最优子结构  动态递推m
  * 动态规划 和 递归或者分治，没有根本上的区别（关键看有无最优子结构）
  * 共性：找到重复子问题
  * 差异性： 最优子结构、中途可以淘汰次优解  
  * 
  * 1、最优子结构 opt[n] = best_of(opt[n - 1], opt[n - 2])
  * 2、存储中间状态: opt[i]
  * 3、递推公式
  * opt[i] = opt[i -1] + opt[i - 2];
  * 二位路径: opt[i, j]  = opt[i-1][j] + opt[i][j - 1];
  */
 //斐波拉且

var recur = (n) => {
  let f1 = 1, f0 = 0;
  for (let i = 2; i < n; i++) {
    f2 = f1 + f0;
    f0 = f1;
    f1 = f2;
  }
  return f2;
}

//状态转移方程
fn = () => {
  opt[i, j] = opt[i - 1, j] + opt[i, j - 1]

  //完整逻辑
  if (a[i, j] !== '') {
    opt[(i, j)] = opt[(i - 1, j)] + opt[(i, j - 1)];
  } else {
    opt[i, j] = 0
  }
}