### react是什么
核心思路
- 声明式
  - 声明式编程的优势在于直观，可以做到一目了然，也便于组合
- 组件化
  - 组件化降低了系统间功能的耦合性，提高功能内部的聚合性
- 通用性
  - react将dom抽象为虚拟dom，开发者不在直接操作dom,使得react不在局限于web开发，从而走向更宽广的平台

优缺点：
- 声明式，组件化，通用性
- 缺点：react并不是一个一揽子框架，导致在技术选型和学习使用上有比较高的成本，导致两级分化严重

react是什么：
- react是用于构建用户界面的javaScript库，通过组件化的凡是解决视图层开发复用的问题
- 他的核心设计思路有三点，分别是声明式，组件化，通用性
- 声明式的优点在于直观与组合
- 组件化的优点在于试图的拆分和模块复用，可以更容易做到高内聚低耦合
- 通用性在于一次学习，随处编写，比如react active，react360， 这里主要靠虚拟dom来保证实现
- 这使得react的适用范围变得足够宽广，无论式web,native, vr甚至shell应用，都可以进行开发，这也是react的优势
- react也有他的缺点，因为不是一揽子解决方案，在开发大型前端应用时，需要想社区寻找整合最佳解决方案，虽然在一定程度上丰富了社区的繁荣，但是也为开发者在技术选型和学习适用上造成一定的成本。

### 为什么react要用jsx
jsx是什么：是一个js的语法拓展，结构类型xml,主要用于申明react元素，但react并不强制使用jsx,即使使用了，也会构建的过程中，通过babel编译为react.createElement,所以jsx更像是react.createElement的一种语法糖，所以也可以从这里看出，react团队并不想引入JavaScript以外的开发体系，而是希望通过合理的关注点分离，保持开发的纯粹性

方案对比：
- 模板，react团队认为，模板不应是开发过程中的关注点，因为也引入了模板语法，模板指令是一种不加的实现方案，因为这样弱化了开发过程的关注点和引入过多的概念，造成可读性的困难
- 模板字符串，模板字符编写的结构会造成结构描述复杂，会使得优化变得困难，语法提示差
- 所以react推荐使用jsx

babel插件如何实现jsx到js的编译？
- babel读取代码，并解析，生成ast
- ast传入插件层，进行转化，在转化的过程中，就可以将jsx的结构转为React.createElement()函数，

### 如何避免声明周期的坑
社区中移除constructor的原因（哪个版本移除的）
- constructor中并不推荐去处理初始化以外的逻辑
- constructor不属于react的生命周期，知识class的初始化函数
- 通过移除constructor，代码也会变得更加简洁

shouldComonentUpdate,该方法通过返回true或者false来判断是否需要执行渲染，因为是渲染触发的最后一道关卡，所以是react性能优化的必争之地，通过添加判断条件来阻止不必要的渲染，react官方提供一个通用的优化方案，pureComponent，纯组件的核心原理就是默认实现了shouldComponentUpdate,在这个函数中，对props和state进行浅比较，用来判断是否促发更新，浅比较只是比较值和引用的区别，不会再去比较里面内部的值
```
shouldComponentUpdate(nextProps, nextState) {
  if(shadowEqual(nextProps, this.props) || shadowEqual(nextState, this.state)) {
    return true;
  }
  return false;
}
```
```
浅比较只是比较第一层，对于基本的数据类型，只比较值，对于引用数据类型，直接比较地址是否相同，不管里面的内容是否变化，如果地址没有发生改变，就认为不会变，基于此种方式，对于应用类型修改属性或者状态的时候，对于赋值时，尽可能的把之前拿过来的值拷贝一份，赋一个新的地址
```
- 什么情况下会触发重新渲染
  - 函数组件，任何情况下都会重新渲染，没有生命周期，官方提供了React.memo的优化手段
  - React.component，不实现shouldcomponentUpdate函数的情况下，有两种情况会触发重新渲染
    - 当state发生变化时，组件会重新渲染
    - 当父组件的props传入时，组件也会重新渲染
  - React.pureComponent组件，该组件默认实现了shouleComponentUpdate函数， 所以仅在props和state进行浅比较后，确认有变化时，才会重新触发渲染
- 渲染中发生报错后会怎么样处理？该如何处理？
- ErrorBundary错误组件
- 但是渲染时的报错，只能通过componentDidCatch捕获

避免生命周期的坑，做好这两件事
1. 在不恰当的时候，不该调用不该调用的代码，
2. 在需要调用的时候，不要忘了调用
- getDerivedStateFromProps ,容易编写反例代码，使受控组件和非受控组件的区分模糊
- componentWillMount，已经弃用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。
- componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。
- shouldComponentUpdate,用来控制是否渲染
- componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。
- 定时器的清楚
- 错误边界的添加
  
### 类组件和函数组件的区别
- 共同点，实际的用途一样，无论高阶组件还是异步加载，都可以用作基础组件展示ui
- 不同点：
- 代表两种不同设计思想和心智模式
- 类组件的根基是oop，面向对象编程
- 函数组件的根基是fp,也就是函数式编程
- 相较于类组件，函数组件更纯粹，简单，更易测试
- 由于根本思考方式不同，类组件通过声明周期包装业务组件逻辑
- 性能优化
  - 类组件依赖shouldComponentUpdate函数去阻断渲染
  - 函数组件靠react.memo来优化

类组件的模式并不能友好的使用未来的趋势的原因有：
- this的模糊性
- 业务逻辑散落在声明周期中
- React的组件代码缺乏标准的拆分方式

而使用 Hooks 的函数组件可以提供比原先更细粒度的逻辑组织与复用，且能更好地适用于时间切片与并发模式。

思考方向
- 作为组件而言，类组件和函数组件在使用与呈现上没有任何区别，性能上在现代浏览器中也不会有明显的差异
- 他们在开发时的心智模型上却存在巨大的差异，类组件是面向对象编程的，它主打的是继承，生命周期邓核心概念；而函数组件是函数式编程，主打的是不可变（immutable），没有副作用，引用透明等
- 之前，在使用场景上，如果存在需要使用生命周期的组件，那么推荐使用类组件；如果是设计模式上，如果需要使用继承，推荐使用类组件
- 由于react hooks的推出，生命周期概念的淡出，函数组件可以完全取代类组件
- 其次继承并不是最佳的设计模式，官方更加的推荐“组合由于继承”的设计概念，所以类组件在这方面的优势也在淡出
- 从性能优化上来看，类组件主要依赖shouldComponentUpdate阻断渲染来提升性能，而函数组件依靠React.memo（）缓存的方式渲染结果来提升性能
- 从上手程度而言，类组件更容易上手，从未来趋势来看，函数组件成为社区的主打组件
- 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不容易优化。而函数组件本身轻量简单，且在hooks的基础上提供了比原来更细粒度的逻辑组织与复用，更能使用React的未来发展
  
### 如何设计React组件
装饰器
- 从设计上来说，社区主流分类为展示组件和业务组件
- 展示组件内部没有状态管理，仅仅用于最简单的展示表达。展示组件最基础的一类组件被称为代理组件。代理组件常用于封装常用属性，减少重复代码，还可以隔离第三方的组件
- 业务组件，功能丰富，复杂性更高，复用度低于展示组件
- 从工程上来说，还可以通过文件夹的划分来切分代码

