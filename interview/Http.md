### 区别
|     | 1.0  | 1.1 | 2.0
|  ----  | ----  | ---- | ---- |
| 缓存处理  |使用if-modified-sice，expires  |添加了max-age, if-none-match / etag |  |
| 宽带优化及网络连接使用  | 浪费宽带，例如用户只需某个对象的一部分，服务器会把整个对象返回来，并且不支持断点续传功能  | 引入range，允许只请求某部分 |
| 错误通知管理  |  |
| host头处理  | 默认每台服务器都绑定一个唯一ip  |随着虚拟机的发展，一个物理服务器可以有多个虚拟主机，并且共享一个ip，因此支持了host，并且也必须有host |
| 长连接  |没有长连接，每次请求都要tcp连接  |使用connection: keep-alive，表明长连接， 管道化，可以发送多个请求同时，但是返回数据也是依次的，因此也有队头阻塞|
|二进制传输| 解析基于文本，文本格式繁多，考虑的场景很多 |和1.0一样 | 只有0和1，实现方便且健壮 |
| 多路复用  |  | | 连接共享，多个连接使用一个tcp，多个连接可以混杂再一起，然后通过requestId来归属到各自不同的服务端请求里面|
| header压缩  |  | |由于header的庞大，因此进行了header的压缩， 首部字段压缩是指客户端和服务端通过使用“首部表”来追踪和存储之前发送的键值对，对于相同的数据，不会每次请求和响应都发送 |
| 服务端推送  |  | |服务端自动推送数据 |

HTTP/0.9

客户端：构建请求、通过DNS查找IP地址、三次握手建立TCP连接、客户端发起请求

服务端：服务器响应、四次挥手断开TCP连接

一次请求完成

总的来说，1991年的需求特别简单，主要用于学术的交流，并且用来传输体积很小的HTML文本文件，因此HTTP/0.9有三个特点：
1. 只有一个请求行，如GET /index.html（就可以完成请求）,没有http请求头和请求体
2. 服务器没有响应信息，这是因为服务器不需要告诉客户端太多的信息，只需要返回数据就行
3. 返回的内容是以ASCII字符流来传输的，因为都是HTML格式的文件，所以使用ASCII字节码合适

### 被浏览器推动的 HTTP/1.0
在1994年，出现了拨号上网服务，并且网景又推出了一款浏览器，从此万维网不在局限于学术交流，而是有了其他发展，在浏览器中，展示的文件类型不在单是HTML文件，而是包括了js，CSS，图片，音频，视频等不同的文件，因此支持多种类型的下载成了HTTP/1.0的新亮点，同时文件传输的格式也不在局限与ASCII编码

之前在HTTP/0.9的时候，只需要一行GET /index.html就可以下载文件，但是现在这种简单的形式已经不能满足多类型文件传输的需求，所以为了客户端和服务端更加准确的识别，HTTP/1.0加入了请求行请求头和响应头响应体，以key-value形式保留;

并且为了表示对多文件的良好支持，还引入了很多特性，比如：
1. 状态码，通过响应行的方式来通知浏览器；
2. Cache机制，减轻服务器压力，浏览器会缓存数据
3. 用户代理字段

### 缝缝补补的 HTTP/1.1
随着技术的不断更新，HTTP/1.0又出现了新问题，因此在HTTP/1.0的基础上做了大量的修改从而推出了HTTP/1.1
1. 改进持久连接，在HTTP/1.1中默认打开，关闭可以在请求头上加Connection: close
   1. HTTP/1.0每进行一次通信，都需要建立TCP连接、传输数据、断开TCP三个阶段,浏览器对于相同域名有最多TCP同时连接的限制，chrome6个
2. 不成熟的管线化
   1. 虽然目前的持久连接，减少了TCP的建立和断开，但是有个缺点就是必须等前面的请求响应返回数据之后，才能进行下一次请求，如果子啊TCP中有些请求因为某些原因没有及时返回就会造成请求阻塞，这就是著名的**队头阻塞**问题
   2. HTTP/1.1试图通过管线化的方式来解决**队头阻塞***问题，HTTP/1.1中的管线化是指将多个HTTP请求批量提给服务器的技术，虽然请求可以批量发送，不过服务器还是要更具请求顺序来回复浏览器请求，fireFox, chrome都尝试过，但是都放弃了
3. 提供虚拟机的支持 Host
   1. 在HTTP/1.0中，每个域名都绑定了一个唯一的IP地址，因此一个服务器就只能支持一个域名，但随着虚拟机的发展，可以在一台物理主机上绑定多个虚拟机，每个虚拟机都有自己的单独的域名，这些单独的域名都公用一个IP地址。并且回在HTTP/1.1的请求头中添加Host字段，用来表示当前域名的地址，这样服务器就可以根据不同的Host值做处理了
4. 对动态生成的内容提供了完美支持
   1. 在HTTP/1.0阶段，需要在响应头中设置完整的数据大小，例如Content-Length：1024，这样浏览器就会根据设置的大小来接受数据，随着服务器技术的发展，很多页面的内容都是动态生成的，因此在数据传输之前都不知道数据的大小，从而浏览器就不知道什么时候接受完所有文件数据
   2. HTTP/1.1 **Chunk transfer**机制解决此问题，服务器将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的数据块作为发送数据结束的标志，这样就动态提供对内容的支持。
5. 客户端Cookie，安全机制
   1. HTTP/1.1还引入了客服端Cookie机制和安全机制


# HTTP/2 
上面讲解了HTTP/1.1虽然做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们的需求，但是HTTP/1.1存在哪些问题了，HTTP/2又是如何解决的了

HTTP/1.1的特点：
1. 增加了持久连接
2. 浏览器最多对每个域名维护6个TCP持久连接
3. 使用CDN实现域名分片机制（虚拟机Host）

HTTP/1.1的主要问题：
1. **对带宽的利用率不理想**，带宽是指每秒最大能发送或者接收的字节数，每秒能发送的最大字节数成为**上行带宽**，每秒能接收的最大字节数称为**下行带宽**，造成原因
   1. TCP慢启动，并且会造成首次渲染缓慢的问题
   2. 多个TCP连接，带宽抢夺
   3. 对头阻塞问题

HTTP/2的特点
1. 多路复用
2. 请求并行，任何时候都可以把请求发送给服务器，也不需要等到其他请求的完成，服务器可以随时返回处理好的数据给浏览器
总结一句话：使用多路复用，实现了一个域名只用一个TCP连接和消除了队头阻塞问题，每个请求通过id来区分

HTTP/2使用多路复用的技术，可以将请求分成一帧一帧的数据去请求，这样带来了一个额外的好处，就是当收到优先级更高的请求时，比如js的关键资源请求，服务器就可以暂停之前的请求优先来处理关键资源的请求。

HTTP/2其他特性
1. 设置请求的优先级，浏览器控制一般为HTML > css > js
2. 服务器推送，例如用户请求HTML文件，这时候服务器知道该HTML文件引用了哪些js和css，就在收到HTML请求之后，顺便也把JS和CSS的文件也推动给浏览器，这对首次渲染速度起了至关重要的的作用
3. 压缩头部，无论时HTTP/1.1还是HTTP/2，他们都拥有请求头和响应头，这是浏览器和服务器交流的关键信息，而HTTP/2对请求头和响应头都做了压缩，想想一下，浏览器在发送请求的时候，一般都是发送的请求头，通常页面有100个资源，如果将100个请求头压缩为原来的20%，传输效率肯定快。

HTTP/2缺点
1. TCP的对头阻塞
2. TCP建立连接的延时
3. TCP协议僵化

HTTP/3使用QUIC保证了数据传输的可靠性，同时利用TLS保证数据的安全性，UDP保证数据握手的快速性