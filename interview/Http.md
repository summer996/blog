### 区别

|                        | 1.0                                                                                      | 1.1                                                                                                              | 2.0                                                                                                                                                                 |
| ---------------------- | ---------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 缓存处理               | 使用 last-modified(if-modified-since)，expires                                                           | 添加了 max-age, if-none-match / etag                                                                             |                                                                                                                                                                     |
| 宽带优化及网络连接使用 | 浪费宽带，例如用户只需某个对象的一部分，服务器会把整个对象返回来，并且不支持断点续传功能 | 引入 range，允许只请求某部分                                                                                     |
| 错误通知管理           |                                                                                          |
| host 头处理            | 默认每台服务器都绑定一个唯一 ip                                                          | 随着虚拟机的发展，一个物理服务器可以有多个虚拟主机，并且共享一个 ip，因此支持了 host，并且也必须有 host          |
| 长连接                 | 没有长连接，每次请求都要 tcp 连接                                                        | 使用 connection: keep-alive，表明长连接， 管道化，可以发送多个请求同时，但是返回数据也是依次的，因此也有队头阻塞 |
| 二进制传输             | 解析基于文本，文本格式繁多，考虑的场景很多                                               | 和 1.0 一样                                                                                                      | 只有 0 和 1，实现方便且健壮                                                                                                                                         |
| 多路复用               |                                                                                          |                                                                                                                  | 连接共享，多个连接使用一个 tcp，多个连接可以混杂再一起，然后通过 requestId 来归属到各自不同的服务端请求里面                                                         |
| header 压缩            |                                                                                          |                                                                                                                  | 由于 header 的庞大，因此进行了 header 的压缩， 首部字段压缩是指客户端和服务端通过使用“首部表”来追踪和存储之前发送的键值对，对于相同的数据，不会每次请求和响应都发送 |
| 服务端推送             |                                                                                          |                                                                                                                  | 服务端自动推送数据                                                                                                                                                  |

HTTP/0.9

客户端：构建请求、通过 DNS 查找 IP 地址、三次握手建立 TCP 连接、客户端发起请求

服务端：服务器响应、四次挥手断开 TCP 连接

一次请求完成

总的来说，1991 年的需求特别简单，主要用于学术的交流，并且用来传输体积很小的 HTML 文本文件，因此 HTTP/0.9 有三个特点：

1. 只有一个请求行，如 GET /index.html（就可以完成请求）,没有 http 请求头和请求体
2. 服务器没有响应信息，这是因为服务器不需要告诉客户端太多的信息，只需要返回数据就行
3. 返回的内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码合适

### 被浏览器推动的 HTTP/1.0 1996 年正式发布

在 1994 年，出现了拨号上网服务，并且网景又推出了一款浏览器，从此万维网不在局限于学术交流，而是有了其他发展，在浏览器中，展示的文件类型不在单是 HTML 文件，而是包括了 js，CSS，图片，音频，视频等不同的文件，因此支持多种类型的下载成了 HTTP/1.0 的新亮点，同时文件传输的格式也不在局限与 ASCII 编码

之前在 HTTP/0.9 的时候，只需要一行 GET /index.html 就可以下载文件，但是现在这种简单的形式已经不能满足多类型文件传输的需求，所以为了客户端和服务端更加准确的识别，HTTP/1.0 加入了请求行请求头和响应头响应体，以 key-value 形式保留;

并且为了表示对多文件的良好支持，还引入了很多特性，比如：

1. 状态码，通过响应行的方式来通知浏览器；
2. Cache 机制，减轻服务器压力，浏览器会缓存数据
3. 用户代理字段

### 缝缝补补的 HTTP/1.1 1999 年发布 RFC 文档

随着技术的不断更新，HTTP/1.0 又出现了新问题，因此在 HTTP/1.0 的基础上做了大量的修改从而推出了 HTTP/1.1

1. 改进持久连接，在 HTTP/1.1 中默认打开，关闭可以在请求头上加 Connection: close
   1. HTTP/1.0 每进行一次通信，都需要建立 TCP 连接、传输数据、断开 TCP 三个阶段,浏览器对于相同域名有最多 TCP 同时连接的限制，chrome6 个
2. 不成熟的管线化
   1. 虽然目前的持久连接，减少了 TCP 的建立和断开，但是有个缺点就是必须等前面的请求响应返回数据之后，才能进行下一次请求，如果子啊 TCP 中有些请求因为某些原因没有及时返回就会造成请求阻塞，这就是著名的**队头阻塞**问题
   2. HTTP/1.1 试图通过管线化的方式来解决**队头阻塞\***问题，HTTP/1.1 中的管线化是指将多个 HTTP 请求批量提给服务器的技术，虽然请求可以批量发送，不过服务器还是要更具请求顺序来回复浏览器请求，fireFox, chrome 都尝试过，但是都放弃了
3. 提供虚拟机的支持 Host
   1. 在 HTTP/1.0 中，每个域名都绑定了一个唯一的 IP 地址，因此一个服务器就只能支持一个域名，但随着虚拟机的发展，可以在一台物理主机上绑定多个虚拟机，每个虚拟机都有自己的单独的域名，这些单独的域名都公用一个 IP 地址。并且回在 HTTP/1.1 的请求头中添加 Host 字段，用来表示当前域名的地址，这样服务器就可以根据不同的 Host 值做处理了
4. 对动态生成的内容提供了完美支持
   1. 在 HTTP/1.0 阶段，需要在响应头中设置完整的数据大小，例如 Content-Length：1024，这样浏览器就会根据设置的大小来接受数据，随着服务器技术的发展，很多页面的内容都是动态生成的，因此在数据传输之前都不知道数据的大小，从而浏览器就不知道什么时候接受完所有文件数据
   2. HTTP/1.1 **Chunk transfer**机制解决此问题，服务器将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的数据块作为发送数据结束的标志，这样就动态提供对内容的支持。
5. 客户端 Cookie，安全机制
   1. HTTP/1.1 还引入了客服端 Cookie 机制和安全机制

# HTTP/2

上面讲解了 HTTP/1.1 虽然做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们的需求，但是 HTTP/1.1 存在哪些问题了，HTTP/2 又是如何解决的了

HTTP/1.1 的特点：

1. 增加了持久连接
2. 浏览器最多对每个域名维护 6 个 TCP 持久连接
3. 使用 CDN 实现域名分片机制（虚拟机 Host）

HTTP/1.1 的主要问题：

1. **对带宽的利用率不理想**，带宽是指每秒最大能发送或者接收的字节数，每秒能发送的最大字节数成为**上行带宽**，每秒能接收的最大字节数称为**下行带宽**，造成原因
   1. TCP 慢启动，并且会造成首次渲染缓慢的问题
   2. 多个 TCP 连接，带宽抢夺
   3. 对头阻塞问题

HTTP/2 的特点

1. 多路复用
2. 请求并行，任何时候都可以把请求发送给服务器，也不需要等到其他请求的完成，服务器可以随时返回处理好的数据给浏览器
   总结一句话：使用多路复用，实现了一个域名只用一个 TCP 连接和消除了队头阻塞问题，每个请求通过 id 来区分

HTTP/2 使用多路复用的技术，可以将请求分成一帧一帧的数据去请求，这样带来了一个额外的好处，就是当收到优先级更高的请求时，比如 js 的关键资源请求，服务器就可以暂停之前的请求优先来处理关键资源的请求。

HTTP/2 其他特性

1. 设置请求的优先级，浏览器控制一般为 HTML > css > js
2. 服务器推送，例如用户请求 HTML 文件，这时候服务器知道该 HTML 文件引用了哪些 js 和 css，就在收到 HTML 请求之后，顺便也把 JS 和 CSS 的文件也推动给浏览器，这对首次渲染速度起了至关重要的的作用
3. 压缩头部，无论时 HTTP/1.1 还是 HTTP/2，他们都拥有请求头和响应头，这是浏览器和服务器交流的关键信息，而 HTTP/2 对请求头和响应头都做了压缩，想想一下，浏览器在发送请求的时候，一般都是发送的请求头，通常页面有 100 个资源，如果将 100 个请求头压缩为原来的 20%，传输效率肯定快。

HTTP/2 缺点

1. TCP 的对头阻塞
2. TCP 建立连接的延时
3. TCP 协议僵化

HTTP/3 使用 QUIC 保证了数据传输的可靠性，同时利用 TLS 保证数据的安全性，UDP 保证数据握手的快速性

//https://www.cnblogs.com/cff2121/p/13369785.html

get 会被浏览器记录，post 不会被浏览器记录
