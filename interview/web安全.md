## 前端攻击

https://juejin.cn/post/6844903772930441230

### xss 跨站脚本攻击 cross-site scripting

攻击者把恶意代码通过各种方式注入到用户页面，就可以获取页面信息，然后进行发请求等一些操作

#### xss 防御

为了预防非持久型的 XSS 漏洞，可以有以下操作来预防：

- web 页面渲染的所有内容或者渲染的数据都来自服务端
- 尽量不要从 url, document.referrer, document.forms 等这种 dom api 中获取数据直接渲染
- 前端渲染的时候，对任何的字段都要做转义编码

持久性 xss 就是把一些恶意数据通过表单提交，提交到后台数据库，例如文章留言，提交文本信息等，但是持久性 xss 的成本比较高，必须没有以下的操作，才能 xss 成功

- post 表单提交，后端不做转义处理就直接存入数据库
- 后端输出数据没有做转义就直接返回给前端
- 前端不做任何转移就直接渲染 dom

1、设置白名单
开发者明确告诉浏览器哪些外部资源可以加载和执行，只需要配置规则，然后浏览器就可以进行拦截，在 http header 中添加属性 content-security-policy 就可以设置加载的资源是哪些

2、转义字符
用户的输入永远不可信任，最普遍的做法就是转义输入输出的内容

### csrf 跨站请求伪造攻击（盗取 cookie）

简单来说就是攻击者引诱用户的浏览器去访问一个用户曾经认证过的网站并进行一些操作，如发短信，消息，购买等，由于以前认证过，所以浏览器会认为是真正用户在操作

### 解决方式

- token 不是防 xss 而是防止 csrf 的，csrf 攻击的原因就是浏览器会自动带上 cookie,但是不会自动携带 token
- xss：跨站脚本攻击，攻击者把恶意代码通过各种方式注入到用户页面，就可以获取页面信息，然后进行发请求等一些操作
- csrf（cross site request forgery）：（使用 token 防止）跨站请求攻击，简单来说就是攻击者引诱用户的浏览器去访问一个用户曾经认证过的网站并进行一些操作，如发短信，消息，购买等，由于以前认证过，所以浏览器会认为是真正用户在操作，利用了 web 中用户身份验证的一个漏洞：**简单的身份验证只能保证请求发自某个用户，却不能保证请求本身是用户自愿发出的**

### token 比 cookie 更安全的原因

- cookie：警察看你的身份证，然后给你一个编号，后续的任何操作，都是通过编号来表明你是谁
- token：直接给警察看身份证，任何操作都是通过身份证直接操作
- cookie：登录之后，后端会生成一个 sessionid 放在 cookie 中返回给客户端，并且这个 sessionid 一直存在服务端，以后客户端每次请求都携带这个 sessionid，服务端通过这个 sessionid 来判断身份，如果别人拿到了这个 cookie 就能拿到 sessionid，完全可以取代你做其他请求。
- token：登录之后，后端会返回一个 token，以后的每次请求，前端都需要手动加上这个 token，即使被劫持，由于 jwt+ip 的方式，也会是一个无效的 token;

原因：

- 浏览器在请求时，会自动带上 cookie,所以 crsf 才管用
- token,不会自动携带，并且 token 是放在 jwt 里面发送给客户的，不能通过脚本拿到，加上 jwt+ip 的方式，可以防止被劫持，即使劫持，也是无效的 jwt

### SQL 注入

正常语句`js SELECT * FROM user WHERE username='admin' AND psw='password'`

攻击语句`js SELECT * FROM user WHERE username='admin'--' AND psw='password'`
在 SQL 中，' --就是闭合和注释的意思，后面就是住释的内容，因此查询语句就变成了`SELECT * FROM user WHERE username='admin'`
